// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunk.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (
  source_id, source_path, source_filename, source_mime, source_page, department, language, text, embedding_vector, embedding_json, chunk_hash, created_by, status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, COALESCE($13, 'ready')
)
RETURNING chunk_internal_id, chunk_external_id, source_id, source_path, source_filename, source_mime, source_page, department, language, text, text_tsv, embedding_vector, embedding_json, chunk_hash, created_at, created_by, status
`

type CreateChunkParams struct {
	SourceID        pgtype.UUID `json:"source_id"`
	SourcePath      pgtype.Text `json:"source_path"`
	SourceFilename  pgtype.Text `json:"source_filename"`
	SourceMime      pgtype.Text `json:"source_mime"`
	SourcePage      pgtype.Int4 `json:"source_page"`
	Department      pgtype.Text `json:"department"`
	Language        pgtype.Text `json:"language"`
	Text            string      `json:"text"`
	EmbeddingVector []byte      `json:"embedding_vector"`
	EmbeddingJson   []byte      `json:"embedding_json"`
	ChunkHash       pgtype.Text `json:"chunk_hash"`
	CreatedBy       pgtype.UUID `json:"created_by"`
	Column13        interface{} `json:"column_13"`
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.SourceID,
		arg.SourcePath,
		arg.SourceFilename,
		arg.SourceMime,
		arg.SourcePage,
		arg.Department,
		arg.Language,
		arg.Text,
		arg.EmbeddingVector,
		arg.EmbeddingJson,
		arg.ChunkHash,
		arg.CreatedBy,
		arg.Column13,
	)
	var i Chunk
	err := row.Scan(
		&i.ChunkInternalID,
		&i.ChunkExternalID,
		&i.SourceID,
		&i.SourcePath,
		&i.SourceFilename,
		&i.SourceMime,
		&i.SourcePage,
		&i.Department,
		&i.Language,
		&i.Text,
		&i.TextTsv,
		&i.EmbeddingVector,
		&i.EmbeddingJson,
		&i.ChunkHash,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Status,
	)
	return i, err
}

const deleteChunk = `-- name: DeleteChunk :exec
DELETE FROM chunks
WHERE chunk_external_id = $1
`

func (q *Queries) DeleteChunk(ctx context.Context, chunkExternalID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteChunk, chunkExternalID)
	return err
}

const getChunkByID = `-- name: GetChunkByID :one
SELECT chunk_internal_id, chunk_external_id, source_id, source_path, source_filename, source_mime, source_page, department, language, text, text_tsv, embedding_vector, embedding_json, chunk_hash, created_at, created_by, status FROM chunks
WHERE chunk_external_id = $1 LIMIT 1
`

func (q *Queries) GetChunkByID(ctx context.Context, chunkExternalID uuid.UUID) (Chunk, error) {
	row := q.db.QueryRow(ctx, getChunkByID, chunkExternalID)
	var i Chunk
	err := row.Scan(
		&i.ChunkInternalID,
		&i.ChunkExternalID,
		&i.SourceID,
		&i.SourcePath,
		&i.SourceFilename,
		&i.SourceMime,
		&i.SourcePage,
		&i.Department,
		&i.Language,
		&i.Text,
		&i.TextTsv,
		&i.EmbeddingVector,
		&i.EmbeddingJson,
		&i.ChunkHash,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Status,
	)
	return i, err
}

const listChunksBySource = `-- name: ListChunksBySource :many
SELECT chunk_internal_id, chunk_external_id, source_id, source_path, source_filename, source_mime, source_page, department, language, text, text_tsv, embedding_vector, embedding_json, chunk_hash, created_at, created_by, status FROM chunks
WHERE source_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListChunksBySource(ctx context.Context, sourceID pgtype.UUID) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, listChunksBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ChunkInternalID,
			&i.ChunkExternalID,
			&i.SourceID,
			&i.SourcePath,
			&i.SourceFilename,
			&i.SourceMime,
			&i.SourcePage,
			&i.Department,
			&i.Language,
			&i.Text,
			&i.TextTsv,
			&i.EmbeddingVector,
			&i.EmbeddingJson,
			&i.ChunkHash,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChunksFulltext = `-- name: SearchChunksFulltext :many
SELECT chunk_external_id, text, ts_rank_cd(text_tsv, query) AS rank
FROM chunks, to_tsquery('simple', $1) AS query
WHERE text_tsv @@ query
ORDER BY rank DESC
LIMIT $2
`

type SearchChunksFulltextParams struct {
	ToTsquery string `json:"to_tsquery"`
	Limit     int32  `json:"limit"`
}

type SearchChunksFulltextRow struct {
	ChunkExternalID uuid.UUID `json:"chunk_external_id"`
	Text            string    `json:"text"`
	Rank            float32   `json:"rank"`
}

func (q *Queries) SearchChunksFulltext(ctx context.Context, arg SearchChunksFulltextParams) ([]SearchChunksFulltextRow, error) {
	rows, err := q.db.Query(ctx, searchChunksFulltext, arg.ToTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchChunksFulltextRow
	for rows.Next() {
		var i SearchChunksFulltextRow
		if err := rows.Scan(&i.ChunkExternalID, &i.Text, &i.Rank); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChunkEmbedding = `-- name: UpdateChunkEmbedding :exec
UPDATE chunks
SET embedding_vector = $2,
    embedding_json = $3
WHERE chunk_external_id = $1
`

type UpdateChunkEmbeddingParams struct {
	ChunkExternalID uuid.UUID `json:"chunk_external_id"`
	EmbeddingVector []byte    `json:"embedding_vector"`
	EmbeddingJson   []byte    `json:"embedding_json"`
}

func (q *Queries) UpdateChunkEmbedding(ctx context.Context, arg UpdateChunkEmbeddingParams) error {
	_, err := q.db.Exec(ctx, updateChunkEmbedding, arg.ChunkExternalID, arg.EmbeddingVector, arg.EmbeddingJson)
	return err
}

const updateChunkStatus = `-- name: UpdateChunkStatus :exec
UPDATE chunks
SET status = $2, created_at = created_at
WHERE chunk_external_id = $1
`

type UpdateChunkStatusParams struct {
	ChunkExternalID uuid.UUID   `json:"chunk_external_id"`
	Status          pgtype.Text `json:"status"`
}

func (q *Queries) UpdateChunkStatus(ctx context.Context, arg UpdateChunkStatusParams) error {
	_, err := q.db.Exec(ctx, updateChunkStatus, arg.ChunkExternalID, arg.Status)
	return err
}
