// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ai_knowledge.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createKnowledge = `-- name: CreateKnowledge :one
INSERT INTO ai_knowledge (
  source_chunk_id, source_text, source_meta, embedding_vector, embedding_json, created_by
) VALUES (
  $1, $2, COALESCE($3, '{}'::jsonb), $4, $5, $6
)
RETURNING id, knowledge_external_id, source_chunk_id, source_text, source_meta, embedding_vector, embedding_json, created_at, created_by
`

type CreateKnowledgeParams struct {
	SourceChunkID   pgtype.UUID `json:"source_chunk_id"`
	SourceText      string      `json:"source_text"`
	Column3         interface{} `json:"column_3"`
	EmbeddingVector []float64   `json:"embedding_vector"`
	EmbeddingJson   []byte      `json:"embedding_json"`
	CreatedBy       pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateKnowledge(ctx context.Context, arg CreateKnowledgeParams) (AiKnowledge, error) {
	row := q.db.QueryRow(ctx, createKnowledge,
		arg.SourceChunkID,
		arg.SourceText,
		arg.Column3,
		arg.EmbeddingVector,
		arg.EmbeddingJson,
		arg.CreatedBy,
	)
	var i AiKnowledge
	err := row.Scan(
		&i.ID,
		&i.KnowledgeExternalID,
		&i.SourceChunkID,
		&i.SourceText,
		&i.SourceMeta,
		&i.EmbeddingVector,
		&i.EmbeddingJson,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteKnowledge = `-- name: DeleteKnowledge :exec
DELETE FROM ai_knowledge
WHERE knowledge_external_id = $1
`

func (q *Queries) DeleteKnowledge(ctx context.Context, knowledgeExternalID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteKnowledge, knowledgeExternalID)
	return err
}

const getKnowledgeByID = `-- name: GetKnowledgeByID :one
SELECT id, knowledge_external_id, source_chunk_id, source_text, source_meta, embedding_vector, embedding_json, created_at, created_by FROM ai_knowledge
WHERE knowledge_external_id = $1
LIMIT 1
`

func (q *Queries) GetKnowledgeByID(ctx context.Context, knowledgeExternalID uuid.UUID) (AiKnowledge, error) {
	row := q.db.QueryRow(ctx, getKnowledgeByID, knowledgeExternalID)
	var i AiKnowledge
	err := row.Scan(
		&i.ID,
		&i.KnowledgeExternalID,
		&i.SourceChunkID,
		&i.SourceText,
		&i.SourceMeta,
		&i.EmbeddingVector,
		&i.EmbeddingJson,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const searchKnowledgeFulltext = `-- name: SearchKnowledgeFulltext :many
SELECT 
    id, knowledge_external_id, source_text, ts_rank_cd(to_tsvector('simple', source_text), to_tsquery('simple', $1)) AS rank
FROM ai_knowledge
WHERE to_tsvector('simple', source_text) @@ to_tsquery('simple', $1)
ORDER BY rank DESC
LIMIT $2
`

type SearchKnowledgeFulltextParams struct {
	ToTsquery string `json:"to_tsquery"`
	Limit     int32  `json:"limit"`
}

type SearchKnowledgeFulltextRow struct {
	ID                  pgtype.Int8 `json:"id"`
	KnowledgeExternalID uuid.UUID   `json:"knowledge_external_id"`
	SourceText          string      `json:"source_text"`
	Rank                float32     `json:"rank"`
}

func (q *Queries) SearchKnowledgeFulltext(ctx context.Context, arg SearchKnowledgeFulltextParams) ([]SearchKnowledgeFulltextRow, error) {
	rows, err := q.db.Query(ctx, searchKnowledgeFulltext, arg.ToTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchKnowledgeFulltextRow
	for rows.Next() {
		var i SearchKnowledgeFulltextRow
		if err := rows.Scan(
			&i.ID,
			&i.KnowledgeExternalID,
			&i.SourceText,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateKnowledgeEmbedding = `-- name: UpdateKnowledgeEmbedding :exec
UPDATE ai_knowledge
SET embedding_vector = $2,
    embedding_json = $3
WHERE knowledge_external_id = $1
`

type UpdateKnowledgeEmbeddingParams struct {
	KnowledgeExternalID uuid.UUID `json:"knowledge_external_id"`
	EmbeddingVector     []float64 `json:"embedding_vector"`
	EmbeddingJson       []byte    `json:"embedding_json"`
}

func (q *Queries) UpdateKnowledgeEmbedding(ctx context.Context, arg UpdateKnowledgeEmbeddingParams) error {
	_, err := q.db.Exec(ctx, updateKnowledgeEmbedding, arg.KnowledgeExternalID, arg.EmbeddingVector, arg.EmbeddingJson)
	return err
}
