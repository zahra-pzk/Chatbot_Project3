// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_attachments.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachmentsByMessage = `-- name: CountAttachmentsByMessage :one
SELECT COUNT(*) AS count
FROM message_attachments
WHERE message_external_id = $1
`

func (q *Queries) CountAttachmentsByMessage(ctx context.Context, messageExternalID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachmentsByMessage, messageExternalID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachment = `-- name: CreateAttachment :one
INSERT INTO message_attachments (
    message_external_id,
    user_external_id,
    chat_external_id,
    url,
    filename,
    mime_type,
    size_bytes,
    metadata,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW()
)
RETURNING attachment_id, attachment_external_id, message_external_id, user_external_id, chat_external_id, url, filename, mime_type, size_bytes, metadata, created_at
`

type CreateAttachmentParams struct {
	MessageExternalID uuid.UUID   `json:"message_external_id"`
	UserExternalID    uuid.UUID   `json:"user_external_id"`
	ChatExternalID    uuid.UUID   `json:"chat_external_id"`
	Url               string      `json:"url"`
	Filename          pgtype.Text `json:"filename"`
	MimeType          pgtype.Text `json:"mime_type"`
	SizeBytes         pgtype.Int8 `json:"size_bytes"`
	Metadata          []byte      `json:"metadata"`
}

func (q *Queries) CreateAttachment(ctx context.Context, arg CreateAttachmentParams) (MessageAttachment, error) {
	row := q.db.QueryRow(ctx, createAttachment,
		arg.MessageExternalID,
		arg.UserExternalID,
		arg.ChatExternalID,
		arg.Url,
		arg.Filename,
		arg.MimeType,
		arg.SizeBytes,
		arg.Metadata,
	)
	var i MessageAttachment
	err := row.Scan(
		&i.AttachmentID,
		&i.AttachmentExternalID,
		&i.MessageExternalID,
		&i.UserExternalID,
		&i.ChatExternalID,
		&i.Url,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAttachment = `-- name: DeleteAttachment :exec
DELETE FROM message_attachments
WHERE attachment_external_id = $1
`

func (q *Queries) DeleteAttachment(ctx context.Context, attachmentExternalID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachment, attachmentExternalID)
	return err
}

const deleteAttachmentsByMessage = `-- name: DeleteAttachmentsByMessage :exec
DELETE FROM message_attachments
WHERE message_external_id = $1
`

func (q *Queries) DeleteAttachmentsByMessage(ctx context.Context, messageExternalID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachmentsByMessage, messageExternalID)
	return err
}

const getAttachment = `-- name: GetAttachment :one
SELECT attachment_id, attachment_external_id, message_external_id, user_external_id, chat_external_id, url, filename, mime_type, size_bytes, metadata, created_at
FROM message_attachments
WHERE attachment_external_id = $1
LIMIT 1
`

func (q *Queries) GetAttachment(ctx context.Context, attachmentExternalID uuid.UUID) (MessageAttachment, error) {
	row := q.db.QueryRow(ctx, getAttachment, attachmentExternalID)
	var i MessageAttachment
	err := row.Scan(
		&i.AttachmentID,
		&i.AttachmentExternalID,
		&i.MessageExternalID,
		&i.UserExternalID,
		&i.ChatExternalID,
		&i.Url,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getAttachmentsMetadataByChat = `-- name: GetAttachmentsMetadataByChat :many
SELECT message_external_id, COUNT(*) AS attachment_count, SUM(COALESCE(size_bytes,0)) AS total_bytes
FROM message_attachments
WHERE chat_external_id = $1
GROUP BY message_external_id
ORDER BY total_bytes DESC
LIMIT $2 OFFSET $3
`

type GetAttachmentsMetadataByChatParams struct {
	ChatExternalID uuid.UUID `json:"chat_external_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type GetAttachmentsMetadataByChatRow struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	AttachmentCount   int64     `json:"attachment_count"`
	TotalBytes        int64     `json:"total_bytes"`
}

func (q *Queries) GetAttachmentsMetadataByChat(ctx context.Context, arg GetAttachmentsMetadataByChatParams) ([]GetAttachmentsMetadataByChatRow, error) {
	rows, err := q.db.Query(ctx, getAttachmentsMetadataByChat, arg.ChatExternalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttachmentsMetadataByChatRow
	for rows.Next() {
		var i GetAttachmentsMetadataByChatRow
		if err := rows.Scan(&i.MessageExternalID, &i.AttachmentCount, &i.TotalBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllAttachmentsByMessage = `-- name: ListAllAttachmentsByMessage :many
SELECT attachment_id, attachment_external_id, message_external_id, user_external_id, chat_external_id, url, filename, mime_type, size_bytes, metadata, created_at
FROM message_attachments
WHERE message_external_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListAllAttachmentsByMessage(ctx context.Context, messageExternalID uuid.UUID) ([]MessageAttachment, error) {
	rows, err := q.db.Query(ctx, listAllAttachmentsByMessage, messageExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageAttachment
	for rows.Next() {
		var i MessageAttachment
		if err := rows.Scan(
			&i.AttachmentID,
			&i.AttachmentExternalID,
			&i.MessageExternalID,
			&i.UserExternalID,
			&i.ChatExternalID,
			&i.Url,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttachmentsByChat = `-- name: ListAttachmentsByChat :many
SELECT attachment_id, attachment_external_id, message_external_id, user_external_id, chat_external_id, url, filename, mime_type, size_bytes, metadata, created_at
FROM message_attachments
WHERE chat_external_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListAttachmentsByChatParams struct {
	ChatExternalID uuid.UUID `json:"chat_external_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

func (q *Queries) ListAttachmentsByChat(ctx context.Context, arg ListAttachmentsByChatParams) ([]MessageAttachment, error) {
	rows, err := q.db.Query(ctx, listAttachmentsByChat, arg.ChatExternalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageAttachment
	for rows.Next() {
		var i MessageAttachment
		if err := rows.Scan(
			&i.AttachmentID,
			&i.AttachmentExternalID,
			&i.MessageExternalID,
			&i.UserExternalID,
			&i.ChatExternalID,
			&i.Url,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttachmentsByMessage = `-- name: ListAttachmentsByMessage :many
SELECT attachment_id, attachment_external_id, message_external_id, user_external_id, chat_external_id, url, filename, mime_type, size_bytes, metadata, created_at
FROM message_attachments
WHERE message_external_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListAttachmentsByMessageParams struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	Limit             int32     `json:"limit"`
	Offset            int32     `json:"offset"`
}

func (q *Queries) ListAttachmentsByMessage(ctx context.Context, arg ListAttachmentsByMessageParams) ([]MessageAttachment, error) {
	rows, err := q.db.Query(ctx, listAttachmentsByMessage, arg.MessageExternalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageAttachment
	for rows.Next() {
		var i MessageAttachment
		if err := rows.Scan(
			&i.AttachmentID,
			&i.AttachmentExternalID,
			&i.MessageExternalID,
			&i.UserExternalID,
			&i.ChatExternalID,
			&i.Url,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
