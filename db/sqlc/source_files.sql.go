// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: source_files.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSourceFile = `-- name: CreateSourceFile :one
INSERT INTO source_files (
  storage_key, filename, mime_type, size_bytes, uploaded_by
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING source_id, source_external_id, storage_key, filename, mime_type, size_bytes, uploaded_by, uploaded_at, processed_at, status
`

type CreateSourceFileParams struct {
	StorageKey string      `json:"storage_key"`
	Filename   pgtype.Text `json:"filename"`
	MimeType   pgtype.Text `json:"mime_type"`
	SizeBytes  pgtype.Int8 `json:"size_bytes"`
	UploadedBy pgtype.UUID `json:"uploaded_by"`
}

func (q *Queries) CreateSourceFile(ctx context.Context, arg CreateSourceFileParams) (SourceFile, error) {
	row := q.db.QueryRow(ctx, createSourceFile,
		arg.StorageKey,
		arg.Filename,
		arg.MimeType,
		arg.SizeBytes,
		arg.UploadedBy,
	)
	var i SourceFile
	err := row.Scan(
		&i.SourceID,
		&i.SourceExternalID,
		&i.StorageKey,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.ProcessedAt,
		&i.Status,
	)
	return i, err
}

const getSourceByExternalID = `-- name: GetSourceByExternalID :one
SELECT source_id, source_external_id, storage_key, filename, mime_type, size_bytes, uploaded_by, uploaded_at, processed_at, status FROM source_files
WHERE source_external_id = $1
`

func (q *Queries) GetSourceByExternalID(ctx context.Context, sourceExternalID uuid.UUID) (SourceFile, error) {
	row := q.db.QueryRow(ctx, getSourceByExternalID, sourceExternalID)
	var i SourceFile
	err := row.Scan(
		&i.SourceID,
		&i.SourceExternalID,
		&i.StorageKey,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.ProcessedAt,
		&i.Status,
	)
	return i, err
}

const listDocumentsByUser = `-- name: ListDocumentsByUser :many
SELECT source_id, source_external_id, filename, mime_type, size_bytes, uploaded_at, status
FROM source_files
WHERE uploaded_by = $1
ORDER BY uploaded_at DESC
`

type ListDocumentsByUserRow struct {
	SourceID         pgtype.Int8        `json:"source_id"`
	SourceExternalID uuid.UUID          `json:"source_external_id"`
	Filename         pgtype.Text        `json:"filename"`
	MimeType         pgtype.Text        `json:"mime_type"`
	SizeBytes        pgtype.Int8        `json:"size_bytes"`
	UploadedAt       pgtype.Timestamptz `json:"uploaded_at"`
	Status           pgtype.Text        `json:"status"`
}

func (q *Queries) ListDocumentsByUser(ctx context.Context, uploadedBy pgtype.UUID) ([]ListDocumentsByUserRow, error) {
	rows, err := q.db.Query(ctx, listDocumentsByUser, uploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDocumentsByUserRow
	for rows.Next() {
		var i ListDocumentsByUserRow
		if err := rows.Scan(
			&i.SourceID,
			&i.SourceExternalID,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.UploadedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedSources = `-- name: ListUploadedSources :many
SELECT source_id, source_external_id, storage_key, filename, mime_type, size_bytes, uploaded_by, uploaded_at, processed_at, status
FROM source_files
ORDER BY uploaded_at DESC
LIMIT $1
`

func (q *Queries) ListUploadedSources(ctx context.Context, limit int32) ([]SourceFile, error) {
	rows, err := q.db.Query(ctx, listUploadedSources, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SourceFile
	for rows.Next() {
		var i SourceFile
		if err := rows.Scan(
			&i.SourceID,
			&i.SourceExternalID,
			&i.StorageKey,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.ProcessedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSourceProcessed = `-- name: MarkSourceProcessed :exec
UPDATE source_files
SET processed_at = now(),
    status = 'processed'
WHERE source_id = $1
`

func (q *Queries) MarkSourceProcessed(ctx context.Context, sourceID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, markSourceProcessed, sourceID)
	return err
}
