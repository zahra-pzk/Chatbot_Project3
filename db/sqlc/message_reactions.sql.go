// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_reactions.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const addOrUpdateReaction = `-- name: AddOrUpdateReaction :one
INSERT INTO message_reactions (
    message_external_id,
    user_external_id,
    reaction,
    score,
    created_at
) VALUES (
    $1, $2, $3, $4, NOW()
)
ON CONFLICT (message_external_id, user_external_id, reaction)
DO UPDATE SET
    score = EXCLUDED.score,
    created_at = NOW()
RETURNING reaction_id, reaction_external_id, message_external_id, user_external_id, reaction, score, created_at
`

type AddOrUpdateReactionParams struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	UserExternalID    uuid.UUID `json:"user_external_id"`
	Reaction          string    `json:"reaction"`
	Score             int64     `json:"score"`
}

func (q *Queries) AddOrUpdateReaction(ctx context.Context, arg AddOrUpdateReactionParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, addOrUpdateReaction,
		arg.MessageExternalID,
		arg.UserExternalID,
		arg.Reaction,
		arg.Score,
	)
	var i MessageReaction
	err := row.Scan(
		&i.ReactionID,
		&i.ReactionExternalID,
		&i.MessageExternalID,
		&i.UserExternalID,
		&i.Reaction,
		&i.Score,
		&i.CreatedAt,
	)
	return i, err
}

const countAllReactionsByMessage = `-- name: CountAllReactionsByMessage :one
SELECT COUNT(*) AS total_count
FROM message_reactions mr
WHERE mr.message_external_id = $1
`

func (q *Queries) CountAllReactionsByMessage(ctx context.Context, messageExternalID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAllReactionsByMessage, messageExternalID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countReactionsByMessage = `-- name: CountReactionsByMessage :many
SELECT 
    mr.reaction, 
    COUNT(*) AS reaction_count, 
    SUM(mr.score) AS total_score
FROM message_reactions mr
WHERE mr.message_external_id = $1
GROUP BY mr.reaction
ORDER BY total_score DESC
`

type CountReactionsByMessageRow struct {
	Reaction      string `json:"reaction"`
	ReactionCount int64  `json:"reaction_count"`
	TotalScore    int64  `json:"total_score"`
}

func (q *Queries) CountReactionsByMessage(ctx context.Context, messageExternalID uuid.UUID) ([]CountReactionsByMessageRow, error) {
	rows, err := q.db.Query(ctx, countReactionsByMessage, messageExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountReactionsByMessageRow
	for rows.Next() {
		var i CountReactionsByMessageRow
		if err := rows.Scan(&i.Reaction, &i.ReactionCount, &i.TotalScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUserReactions = `-- name: CountUserReactions :one
SELECT COUNT(*) AS user_total_reactions
FROM message_reactions mr
WHERE mr.user_external_id = $1
`

func (q *Queries) CountUserReactions(ctx context.Context, userExternalID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserReactions, userExternalID)
	var user_total_reactions int64
	err := row.Scan(&user_total_reactions)
	return user_total_reactions, err
}

const getReactionsSummaryForChat = `-- name: GetReactionsSummaryForChat :many
SELECT 
    mr.reaction, 
    COUNT(*) AS reaction_count, 
    SUM(mr.score) AS total_score
FROM message_reactions mr
JOIN messages m ON m.message_external_id = mr.message_external_id
WHERE m.chat_external_id = $1
GROUP BY mr.reaction
ORDER BY total_score DESC
LIMIT $2 OFFSET $3
`

type GetReactionsSummaryForChatParams struct {
	ChatExternalID uuid.UUID `json:"chat_external_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type GetReactionsSummaryForChatRow struct {
	Reaction      string `json:"reaction"`
	ReactionCount int64  `json:"reaction_count"`
	TotalScore    int64  `json:"total_score"`
}

func (q *Queries) GetReactionsSummaryForChat(ctx context.Context, arg GetReactionsSummaryForChatParams) ([]GetReactionsSummaryForChatRow, error) {
	rows, err := q.db.Query(ctx, getReactionsSummaryForChat, arg.ChatExternalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReactionsSummaryForChatRow
	for rows.Next() {
		var i GetReactionsSummaryForChatRow
		if err := rows.Scan(&i.Reaction, &i.ReactionCount, &i.TotalScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopReactionersInChat = `-- name: GetTopReactionersInChat :many
SELECT 
    mr.user_external_id, 
    COUNT(*) AS reactions_count, 
    SUM(mr.score) AS total_score
FROM message_reactions mr
JOIN messages m ON m.message_external_id = mr.message_external_id
WHERE m.chat_external_id = $1
GROUP BY mr.user_external_id
ORDER BY total_score DESC
LIMIT $2 OFFSET $3
`

type GetTopReactionersInChatParams struct {
	ChatExternalID uuid.UUID `json:"chat_external_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type GetTopReactionersInChatRow struct {
	UserExternalID uuid.UUID `json:"user_external_id"`
	ReactionsCount int64     `json:"reactions_count"`
	TotalScore     int64     `json:"total_score"`
}

func (q *Queries) GetTopReactionersInChat(ctx context.Context, arg GetTopReactionersInChatParams) ([]GetTopReactionersInChatRow, error) {
	rows, err := q.db.Query(ctx, getTopReactionersInChat, arg.ChatExternalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopReactionersInChatRow
	for rows.Next() {
		var i GetTopReactionersInChatRow
		if err := rows.Scan(&i.UserExternalID, &i.ReactionsCount, &i.TotalScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserReactionForMessage = `-- name: GetUserReactionForMessage :one
SELECT 
    mr.reaction_id, 
    mr.reaction_external_id, 
    mr.message_external_id, 
    mr.user_external_id, 
    mr.reaction, 
    mr.score, 
    mr.created_at
FROM message_reactions mr
WHERE mr.message_external_id = $1 
  AND mr.user_external_id = $2 
  AND mr.reaction = $3
LIMIT 1
`

type GetUserReactionForMessageParams struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	UserExternalID    uuid.UUID `json:"user_external_id"`
	Reaction          string    `json:"reaction"`
}

func (q *Queries) GetUserReactionForMessage(ctx context.Context, arg GetUserReactionForMessageParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, getUserReactionForMessage, arg.MessageExternalID, arg.UserExternalID, arg.Reaction)
	var i MessageReaction
	err := row.Scan(
		&i.ReactionID,
		&i.ReactionExternalID,
		&i.MessageExternalID,
		&i.UserExternalID,
		&i.Reaction,
		&i.Score,
		&i.CreatedAt,
	)
	return i, err
}

const insertReactionWithWeight = `-- name: InsertReactionWithWeight :one
INSERT INTO message_reactions (
    message_external_id,
    user_external_id,
    reaction,
    score,
    created_at
)
VALUES (
    $1, $2, $3,
    COALESCE($4, reaction_weight($3)),
    NOW()
)
ON CONFLICT (message_external_id, user_external_id, reaction)
DO UPDATE SET 
    score = EXCLUDED.score,
    created_at = NOW()
RETURNING 
    reaction_id,
    reaction_external_id,
    message_external_id,
    user_external_id,
    reaction,
    score,
    created_at
`

type InsertReactionWithWeightParams struct {
	MessageExternalID uuid.UUID   `json:"message_external_id"`
	UserExternalID    uuid.UUID   `json:"user_external_id"`
	Reaction          string      `json:"reaction"`
	Column4           interface{} `json:"column_4"`
}

func (q *Queries) InsertReactionWithWeight(ctx context.Context, arg InsertReactionWithWeightParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, insertReactionWithWeight,
		arg.MessageExternalID,
		arg.UserExternalID,
		arg.Reaction,
		arg.Column4,
	)
	var i MessageReaction
	err := row.Scan(
		&i.ReactionID,
		&i.ReactionExternalID,
		&i.MessageExternalID,
		&i.UserExternalID,
		&i.Reaction,
		&i.Score,
		&i.CreatedAt,
	)
	return i, err
}

const listAllReactionsByMessage = `-- name: ListAllReactionsByMessage :many
SELECT 
    mr.reaction_id, 
    mr.reaction_external_id, 
    mr.message_external_id, 
    mr.user_external_id, 
    mr.reaction, 
    mr.score, 
    mr.created_at
FROM message_reactions mr
WHERE mr.message_external_id = $1
ORDER BY mr.created_at ASC
`

func (q *Queries) ListAllReactionsByMessage(ctx context.Context, messageExternalID uuid.UUID) ([]MessageReaction, error) {
	rows, err := q.db.Query(ctx, listAllReactionsByMessage, messageExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageReaction
	for rows.Next() {
		var i MessageReaction
		if err := rows.Scan(
			&i.ReactionID,
			&i.ReactionExternalID,
			&i.MessageExternalID,
			&i.UserExternalID,
			&i.Reaction,
			&i.Score,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReactionsByMessage = `-- name: ListReactionsByMessage :many
SELECT 
    mr.reaction_id, 
    mr.reaction_external_id, 
    mr.message_external_id, 
    mr.user_external_id, 
    mr.reaction, 
    mr.score, 
    mr.created_at
FROM message_reactions mr
WHERE mr.message_external_id = $1
ORDER BY mr.created_at ASC
LIMIT $2 OFFSET $3
`

type ListReactionsByMessageParams struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	Limit             int32     `json:"limit"`
	Offset            int32     `json:"offset"`
}

func (q *Queries) ListReactionsByMessage(ctx context.Context, arg ListReactionsByMessageParams) ([]MessageReaction, error) {
	rows, err := q.db.Query(ctx, listReactionsByMessage, arg.MessageExternalID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageReaction
	for rows.Next() {
		var i MessageReaction
		if err := rows.Scan(
			&i.ReactionID,
			&i.ReactionExternalID,
			&i.MessageExternalID,
			&i.UserExternalID,
			&i.Reaction,
			&i.Score,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recomputeChatScore = `-- name: RecomputeChatScore :one
SELECT update_chat_score($1) AS result_score
`

func (q *Queries) RecomputeChatScore(ctx context.Context, pChatUuid uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, recomputeChatScore, pChatUuid)
	var result_score interface{}
	err := row.Scan(&result_score)
	return result_score, err
}

const removeReaction = `-- name: RemoveReaction :exec
DELETE FROM message_reactions
WHERE message_reactions.message_external_id = $1 
  AND message_reactions.user_external_id = $2 
  AND message_reactions.reaction = $3
`

type RemoveReactionParams struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	UserExternalID    uuid.UUID `json:"user_external_id"`
	Reaction          string    `json:"reaction"`
}

func (q *Queries) RemoveReaction(ctx context.Context, arg RemoveReactionParams) error {
	_, err := q.db.Exec(ctx, removeReaction, arg.MessageExternalID, arg.UserExternalID, arg.Reaction)
	return err
}

const toggleReaction = `-- name: ToggleReaction :one
WITH target AS (
    DELETE FROM message_reactions
    WHERE message_reactions.message_external_id = $1 
      AND message_reactions.user_external_id = $2 
      AND message_reactions.reaction = $3
    RETURNING 1 AS deleted_val
),
inserted AS (
    INSERT INTO message_reactions (message_external_id, user_external_id, reaction, score, created_at)
    SELECT 
        CAST($1 AS UUID), 
        CAST($2 AS UUID), 
        CAST($3 AS TEXT), 
        COALESCE(CAST($4 AS BIGINT), reaction_weight(CAST($3 AS TEXT))), 
        NOW()
    WHERE NOT EXISTS (SELECT 1 FROM target)
    RETURNING 1 AS inserted_val
)
SELECT 
    EXISTS (SELECT 1 FROM inserted) AS is_inserted,
    COALESCE((
        SELECT SUM(score_mr.score)
        FROM message_reactions score_mr
        WHERE score_mr.message_external_id IN (
            SELECT target_m.message_external_id 
            FROM messages target_m 
            WHERE target_m.chat_external_id = (
                SELECT chat_m.chat_external_id 
                FROM messages chat_m 
                WHERE chat_m.message_external_id = $1 
                LIMIT 1
            )
        )
    ), 0)::BIGINT AS chat_total_score
`

type ToggleReactionParams struct {
	MessageExternalID uuid.UUID `json:"message_external_id"`
	UserExternalID    uuid.UUID `json:"user_external_id"`
	Reaction          string    `json:"reaction"`
	Column4           int64     `json:"column_4"`
}

type ToggleReactionRow struct {
	IsInserted     bool  `json:"is_inserted"`
	ChatTotalScore int64 `json:"chat_total_score"`
}

func (q *Queries) ToggleReaction(ctx context.Context, arg ToggleReactionParams) (ToggleReactionRow, error) {
	row := q.db.QueryRow(ctx, toggleReaction,
		arg.MessageExternalID,
		arg.UserExternalID,
		arg.Reaction,
		arg.Column4,
	)
	var i ToggleReactionRow
	err := row.Scan(&i.IsInserted, &i.ChatTotalScore)
	return i, err
}
